import { Link } from '@/components/Link'

# Pay

Pay, as the name suggests, allows developers to build native payment experiences directly inside of their mini app.
At launch, WLD and USDC.e will be supported. Gas fees will also be covered.

## Setup

Payments are executed on-chain, so you'll need an <Link href="https://metamask.io/">Ethereum compatible wallet</Link>. Next, whitelist the address in the <Link href="https://developer.worldcoin.org/">Developer Portal</Link>. 


If you try to receive payments at an address that you have not whitelisted, the payment will be rejected.
![Whitelist an Address](/images/docs/mini-apps/commands/pay-setup.png)

## Initiating the payment
Since payment operations are client side, it is important to create your unique id in the backend. Make sure to save this as you should verify this value when you receive the response.
``` tsx {{ title: 'pages/api/initiate-pay.tsx' }}
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    const uuid = crypto.randomUUID().replace(/-/g, "");

    // TODO: Store the ID field in your database

    res.status(200).send(uuid);
}
```
## Sending the command
We currently support WLD and USDC payments. Below is the expected input for the Pay command. For now, payments will all be done on Optimism.
``` tsx {{title: 'PayCommandInput' }}
export type TokensPayload = {
  symbol: Tokens;
  token_amount: string;
};

export type PayCommandInput = {
  reference: string;
  to: string;
  tokens: TokensPayload[];
  network?: Network; // Optional
  description: string;
};
```
Using the Pay command: 
``` tsx {{ title: 'pages/index.tsx' }}
import { MiniKit, tokenToDecimals, Tokens, PayCommandInput } from '@worldcoin/minikit-js'

    const res = await fetch(`/api/initiate-payment`);

    const payload: PayCommandInput = {
        reference: res.text(),
        to: // Your Wallet Address,
        tokens: [
            { symbol: Tokens.WLD, token_amount: tokenToDecimals(1 * credits, Tokens.WLD).toString()},
            { symbol: Tokens.USDCE, token_amount: tokenToDecimals(3 * credits, Tokens.USDCE).toString()}
        ],
        description: "Test example payment for minikit",
    }
    
    if (MiniKit.isInstalled()) {
        MiniKit.commands.pay(payload);
    }
```
## Handling the response
Once World App receives the command, the user will be prompted to confirm the payment via a drawer. Once the app has submitted the payment on chain it will return. 
The response does not wait until the transaction is mined on chain. **Thus, it's critical to confirm the payment in your backend.**
``` tsx {{ title: 'pages/index.tsx' }}
import { MiniKit, tokenToDecimals, Tokens, PayCommandInput, ResponseEvent } from '@worldcoin/minikit-js'
  useEffect(() => {
    if (!MiniKit.isInstalled()) {
      toast.error("Please use as MiniApp to make a purchase");
      return;
    }

    MiniKit.subscribe(
      ResponseEvent.MiniAppPayment,
      async (payload: MiniAppPaymentPayload) => {
        if (payload.status == "success"){
            const payment = await fetch(`/api/confirm-payment`, {payload});
            
            if (payment.success) {
                // Congrats your payment was successful!
            }
        }
      }
    );

    return () => {
      MiniKit.unsubscribe(ResponseEvent.MiniAppPayment);
    };
  }, []);

```

## Verifying the payment
<Note type="warning">
	You should always verify the payment in your backend. Users can manipulate information in the
	frontend, so the response must be verified in a trusted environment.
</Note>

**Web2** applications can call our Developer Portal API to get the current status of the transaction. Since payments are executed on chain, it can take up to a few minutes to confirm.
You can choose to optimistically accept the payments once they've landed on chain, or poll the endpoint to wait till it's successful mined.

**Web3** applications can choose to search the on chain event logs temselves via the `TransferReference` event emitted on chain.
``` solidity {{title : 'TransferReference'}}
event TransferReference(
    address sender,
    address indexed recipient,
    uint256 amount,
    address token,
    string indexed referenceId,
    bool indexed success
);
```
However, in this example, we will show querying via Developer Portal API.
``` tsx {{ title: 'pages/index.tsx' }}
interface IRequestPayload {
  payload: MiniAppPaymentSuccessEventPayload; 
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    const { payload } = req.body as IRequestPayload

    const reference = getReferenceFromDB(user) // TODO

    // 1. Check that the transaction we received from the Mini App is the same one we sent
    if (payload.reference === reference) {
        const response = await fetch(`https://developer.worldcoin.org/api/v2/minikit/transaction/${payload.transactionId}?app_id=${process.env.APP_ID}`, 
            headers: {
                Authorization: `Bearer ${process.env.DEV_PORTAL_API_KEY}`,
            },
        )
        const transaction = await response.json()

        // 2. Here we optimistically confirm the transaction.
        // Otherwise, you can poll until the status == mined
        if (transaction.reference == reference && transaction.status != "failed"){
            res.status(200).send({ success: true }); 
        } else {
            res.status(200).send({ success: false }); 
        }
    }
}
```